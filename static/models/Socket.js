// Generated by CoffeeScript 1.6.3
var Socket, net,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

net = require('net');

module.exports = Socket = (function() {
  function Socket() {
    this.receive = __bind(this.receive, this);
    this.events = {};
    this.socket = null;
    this.connected = false;
    this.buffer = '';
    this.state = {};
    this.expectations = {
      Once: [],
      Anytime: []
    };
    this.on('data', this.receive);
  }

  Socket.prototype.on = function(event, cb) {
    var _base;
    (_base = this.events)[event] || (_base[event] = []);
    return this.events[event].push(cb);
  };

  Socket.prototype.once = function(event, cb) {
    var wrapped,
      _this = this;
    wrapped = null;
    return this.on(event, wrapped = function() {
      var f, i, _i, _len, _ref;
      _ref = _this.events[event];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        f = _ref[i];
        if (!(f === wrapped)) {
          continue;
        }
        _this.events[event].splice(i, 1);
        break;
      }
      return cb.apply(null, arguments);
    });
  };

  Socket.prototype.removeAllListeners = function(event) {
    return delete this.events[event];
  };

  Socket.prototype.emit = function() {
    var args, cb, event, k, _ref, _results;
    event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((this.events[event] != null) && this.events[event].length) {
      _ref = this.events[event];
      _results = [];
      for (k in _ref) {
        cb = _ref[k];
        _results.push(cb.apply(null, args));
      }
      return _results;
    }
  };

  Socket.prototype.emitOne = function() {
    var args, event;
    event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((this.events[event] != null) && this.events[event].length) {
      return this.events[event][0].apply(null, args);
    }
  };

  Socket.prototype.emitLast = function() {
    var args, cb, event;
    event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((this.events[event] != null) && this.events[event].length) {
      cb = this.events[event][this.events[event].length - 1];
      this.events[event] = [];
      return cb.apply(null, args);
    }
  };

  Socket.prototype.emitOneIfAnyThen = function(event, next) {
    if ((this.events[event] != null) && this.events[event].length) {
      return this.events[event][0].call(null, next);
    } else {
      return next();
    }
  };

  Socket.prototype.listen = function(port, cb) {
    var server,
      _this = this;
    server = net.createServer({
      allowHalfOpen: false
    }, function(socket) {
      _this.socket = socket;
      _this.connected = true;
      Logger.out({
        remote: "" + _this.socket.remoteAddress + ":" + _this.socket.remotePort
      }, 'client connected');
      _this.socket.on('data', function(d) {
        return _this.socket_receive.apply(_this, arguments);
      });
      if (typeof cb === 'function') {
        cb(_this.socket);
      }
      return _this.emit('connection');
    });
    server.on('end', function() {
      _this.connected = false;
      return Logger.out({
        type: 'fail'
      }, 'remote host sent FIN');
    });
    server.on('close', function() {
      _this.connected = false;
      Logger.out({
        type: 'fail'
      }, 'socket closed');
      return _this.emit('close');
    });
    server.on('error', function(err) {
      return Logger.out({
        type: 'fail'
      }, "Socket error: " + JSON.stringify(err));
    });
    server.on('timeout', function() {});
    return server.listen(port, function() {
      Logger.out("listening on " + port);
      return _this.emit('listening');
    });
  };

  Socket.prototype.socket_open = function(port, cb) {
    var _this = this;
    this.host = '';
    if (port) {
      this.port = port;
    }
    Logger.out({
      remote: "" + this.host + ":" + this.port
    }, 'opening socket');
    this.socket = new net.Socket({
      allowHalfOpen: false
    });
    this.socket.setTimeout(10 * 1000);
    this.socket.setNoDelay(false);
    this.connected = false;
    this.socket.on('data', function(d) {
      return _this.socket_receive.apply(_this, arguments);
    });
    this.socket.on('end', function() {
      _this.connected = false;
      return Logger.out({
        type: 'fail'
      }, 'remote host sent FIN');
    });
    this.socket.on('close', function() {
      _this.connected = false;
      Logger.out({
        type: 'fail'
      }, 'socket closed');
      return _this.emit('close');
    });
    this.socket.on('error', function(err) {
      return Logger.out({
        type: 'fail'
      }, "Socket error: " + JSON.stringify(err));
    });
    this.socket.on('timeout', function() {});
    this.emit('connecting');
    return this.socket.connect(this.port, function() {
      _this.connected = false;
      Logger.out('socket open');
      if (typeof cb === 'function') {
        cb(_this.socket);
      }
      return _this.emit('connection');
    });
  };

  Socket.prototype.close = function(err) {
    this.connected = false;
    if (err) {
      Logger.out({
        type: 'fail'
      }, "[ERR] " + err);
    }
    Logger.out('sent FIN to remote host');
    this.socket.end();
    Logger.out('destroying socket to ensure no more i/o happens');
    return this.socket.destroy();
  };

  Socket.prototype.socket_send = function(s, cb) {
    var _this = this;
    Logger.out({
      type: 'send'
    }, JSON.stringify(s, null, 2));
    return this.socket.write(s, 'utf8', function() {
      return cb();
    });
  };

  Socket.prototype.socket_receive = function(buf) {
    var cmd, data, packet, pos, recv, _ref, _ref1;
    packet = buf.toString();
    Logger.out({
      type: 'recv'
    }, JSON.stringify(packet, null, 2));
    this.buffer += packet;
    while ((pos = this.buffer.indexOf("\u0000")) !== -1) {
      recv = this.buffer.substr(0, pos);
      this.buffer = this.buffer.substr(pos + 1);
      switch (recv[0]) {
        case '%':
          _ref = recv.substr(1, recv.length - 1).split('%'), cmd = _ref[0], data = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
          this.emit('data', 'd', cmd, data, recv);
          break;
        case '{':
          data = JSON.parse(recv);
          this.emit('data', 'json', (_ref1 = data.b) != null ? _ref1._cmd : void 0, data, recv);
      }
    }
  };

  Socket.prototype.send = function(description, data_callback, cb) {
    Logger.out("send: " + description);
    return this.socket_send(data_callback.apply({
      state: this.state
    }), cb);
  };

  Socket.prototype.hangup = function(reason, cb) {
    Logger.out({
      type: 'fail'
    }, "Server hungup on client. " + reason);
    this.on('close', cb);
    return this.close();
  };

  Socket.prototype._pushExpectation = function() {
    var e, type, _base;
    e = {};
    switch (arguments.length) {
      case 4:
        type = arguments[0], e.description = arguments[1], e.test_callback = arguments[2], e.callback = arguments[3];
        break;
      case 5:
        type = arguments[0], e.description = arguments[1], e.test_callback = arguments[2], e.within = arguments[3], e.callback = arguments[4];
    }
    (_base = this.expectations)[type] || (_base[type] = []);
    this.expectations[type].push(e);
  };

  Socket.prototype.expectOnce = function(description, test_callback, cb) {
    return this._pushExpectation.call(this, 'Once', description, test_callback, cb);
  };

  Socket.prototype.expectOnceWithin = function(description, test_callback, within, cb) {
    return this._pushExpectation.call(this, 'Once', description, test_callback, within, cb);
  };

  Socket.prototype.expectAnytime = function(description, test_callback, cb) {
    return this._pushExpectation.call(this, 'Anytime', description, test_callback, cb);
  };

  Socket.prototype._clearExpectation = function(etype, i) {
    return this.expectations[etype].splice(i, 1);
  };

  Socket.prototype.receive = function(type, cmd, data, recv) {
    var etype, expectation, i, nil, _i, _len, _ref, _ref1;
    _ref = ['Once', 'Anytime'];
    for (nil in _ref) {
      etype = _ref[nil];
      _ref1 = this.expectations[etype];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        expectation = _ref1[i];
        if (expectation.test_callback.apply({
          state: this.state,
          type: type,
          cmd: cmd,
          data: data,
          recv: recv
        })) {
          Logger.out("received " + type + ": " + expectation.description);
          Logger.out({
            type: 'data'
          }, JSON.stringify({
            type: type,
            cmd: cmd,
            data: data
          }));
          if (etype === 'Once') {
            this._clearExpectation(etype, i);
          }
          if (typeof expectation.callback === 'function') {
            expectation.callback.apply({
              state: this.state,
              data: data,
              recv: recv
            });
          }
          return true;
        }
      }
    }
    Logger.out({
      type: 'fail'
    }, 'received: unexpected response');
    Logger.out({
      type: 'fail'
    }, JSON.stringify({
      type: type,
      cmd: cmd,
      data: data
    }));
    Logger.out("expectOnce queue: " + JSON.stringify(this.expectations.Once));
    return Logger.out("expectAnytime queue: " + JSON.stringify(this.expectations.Anytime));
  };

  return Socket;

})();
